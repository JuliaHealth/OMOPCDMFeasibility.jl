var documenterSearchIndex = {"docs":
[{"location":"#OMOPCDMFeasibility","page":"Home","title":"OMOPCDMFeasibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OMOPCDMFeasibility.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#OMOPCDMFeasibility._concept_col-Tuple{Symbol}","page":"Home","title":"OMOPCDMFeasibility._concept_col","text":"_concept_col(tblsym::Symbol) -> Symbol\n\nGenerates the concept column name for a given table symbol.\n\nThis is an internal helper function that constructs the appropriate concept column name based on table naming conventions. Special handling is provided for the person table which uses genderconceptid.\n\nArguments\n\ntblsym - The table symbol\n\nReturns\n\nSymbol - The concept column name for that table\n\nExamples\n\ncol = _concept_col(:condition_occurrence)\n# Returns: :condition_concept_id\n\ncol = _concept_col(:person)\n# Returns: :gender_concept_id\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._counter_reducer-Tuple{Any, Any}","page":"Home","title":"OMOPCDMFeasibility._counter_reducer","text":"_counter_reducer(sub, funcs) -> Any\n\nApplies a sequence of functions to a subject, reducing through function composition.\n\nThis internal helper function sequentially applies each function in the funcs vector to the result of the previous function, starting with sub.\n\nArguments\n\nsub - Initial subject/input to transform\nfuncs - Vector of functions to apply sequentially\n\nReturns\n\nAny - Result after applying all functions\n\nExamples\n\nresult = _counter_reducer([1,2,3], [x -> x .* 2, sum])\n# Equivalent to: sum([1,2,3] .* 2) = sum([2,4,6]) = 12\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._create_cartesian_profile_table-Tuple{DataFrames.DataFrame, Any, Int64, Int64, Any}","page":"Home","title":"OMOPCDMFeasibility._create_cartesian_profile_table","text":"_create_cartesian_profile_table(df, cols, cohort_size, database_size, conn; schema=\"dbt_synthea_dev\", dialect=:postgresql)\n\nCreate a Cartesian product profile table with all covariate combinations.\n\nArguments\n\ndf - DataFrame with demographic data\ncols - Vector of column names to include in combinations\ncohort_size - Total cohort size\ndatabase_size - Total database population size\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\ndialect - SQL dialect (default: :postgresql)\n\nReturns\n\nDataFrame - Table with all covariate combinations and statistics\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._create_individual_profile_table-Tuple{DataFrames.DataFrame, Any, Int64, Int64, Any}","page":"Home","title":"OMOPCDMFeasibility._create_individual_profile_table","text":"_create_individual_profile_table(df, col, cohort_size, database_size, conn; schema=\"dbt_synthea_dev\", dialect=:postgresql)\n\nCreate an individual profile table for a single covariate column.\n\nArguments\n\ndf - DataFrame with demographic data\ncol - Column name to profile\ncohort_size - Total cohort size\ndatabase_size - Total database population size\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\ndialect - SQL dialect (default: :postgresql)\n\nReturns\n\nDataFrame - Profile table with covariate categories and statistics\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._domain_id_to_table-Tuple{String}","page":"Home","title":"OMOPCDMFeasibility._domain_id_to_table","text":"_domain_id_to_table(domain_id::String) -> Symbol\n\nMaps OMOP domain_id strings to their corresponding database table symbols.\n\nThis function provides the mapping between OMOP domain classifications and the actual database tables where those concepts are stored. It includes special handling for person-related domains and falls back to a naming convention for unknown domains.\n\nArguments\n\ndomain_id - OMOP domain identifier string (e.g., \"Condition\", \"Drug\")\n\nReturns\n\nSymbol - Database table symbol (e.g., :conditionoccurrence, :drugexposure)\n\nExamples\n\ntable = _domain_id_to_table(\"Condition\")\n# Returns: :condition_occurrence\n\ntable = _domain_id_to_table(\"Gender\") \n# Returns: :person\n\ntable = _domain_id_to_table(\"CustomDomain\")\n# Returns: :customdomain_occurrence\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._format_number-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility._format_number","text":"_format_number(n) -> String\n\nFormats a number into a human-readable string with appropriate scaling.\n\nThis utility function formats numbers using common abbreviations:\n\nNumbers ≥ 1,000,000 are formatted as \"X.XM\" (millions)\nNumbers ≥ 1,000 are formatted as \"X.XK\" (thousands)  \nNumbers < 1,000 are formatted as integers with ties rounded up\n\nArguments\n\nn - Number to format\n\nReturns\n\nString - Formatted number string\n\nExamples\n\n_format_number(1234567)  # Returns: \"1.2M\"\n_format_number(5432)     # Returns: \"5.4K\" \n_format_number(123)      # Returns: \"123\"\n_format_number(0.5)      # Returns: \"1\"\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._funsql-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility._funsql","text":"_funsql(conn; schema::String=\"main\", dialect::Symbol=:postgresql) -> SQLConnection\n\nCreates a FunSQL connection with database schema reflection.\n\nThis internal function sets up a FunSQL SQLConnection with the appropriate database dialect and schema reflection for query building. Use :postgresql for DuckDB and :sqlite for SQLite.\n\nArguments\n\nconn - Raw database connection\n\nKeyword Arguments\n\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nSQLConnection - FunSQL connection object with reflected schema\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._get_category_name-Tuple{Any, Any, Any}","page":"Home","title":"OMOPCDMFeasibility._get_category_name","text":"_get_category_name(value, col, conn; schema=\"dbt_synthea_dev\", dialect=:postgresql)\n\nGet the human-readable category name for a covariate value.\n\nArguments\n\nvalue - The value to convert (concept ID or string)\ncol - The column name\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\ndialect - SQL dialect (default: :postgresql)\n\nReturns\n\nString - Human-readable category name\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._get_cohort_person_ids-Tuple{Any, Any, Any}","page":"Home","title":"OMOPCDMFeasibility._get_cohort_person_ids","text":"_get_cohort_person_ids(cohort_definition_id, cohort_df, conn; schema=\"dbt_synthea_dev\")\n\nExtract person IDs from either a cohort definition ID or a cohort DataFrame.\n\nArguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing)\ncohort_df - DataFrame containing cohort with person_id column (or nothing)\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\n\nReturns\n\nVector - Vector of unique person IDs\n\nNotes\n\nYou must provide exactly one of cohort_definition_id or cohort_df (not both).\nIf both are provided, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._get_concept_name-Tuple{Any, Any}","page":"Home","title":"OMOPCDMFeasibility._get_concept_name","text":"_get_concept_name(concept_id, conn; schema=\"main\", dialect=:postgresql) -> String\n\nRetrieves the human-readable name for a given OMOP concept ID.\n\nArguments\n\nconcept_id - OMOP CDM concept ID to look up\nconn - Database connection using DBInterface\n\nKeyword Arguments\n\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nString - The concept name, or \"Unknown\" if the concept ID is not found\n\nExamples\n\nname = _get_concept_name(8507, conn)\n# Returns: \"Male\"\n\nname = _get_concept_name(999999, conn) \n# Returns: \"Unknown\"\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._get_concepts_by_domain-Tuple{Vector{<:Integer}, Any}","page":"Home","title":"OMOPCDMFeasibility._get_concepts_by_domain","text":"_get_concepts_by_domain(concept_ids::Vector{<:Integer}, conn; schema=\"main\", dialect=:postgresql) -> Dict{String, Vector{Int}}\n\nGroups a list of OMOP concept IDs by their domain classification.\n\nThis function queries the concept table to determine which domain each concept belongs to (e.g., \"Condition\", \"Drug\", \"Procedure\") and returns them grouped by domain.\n\nArguments\n\nconcept_ids - Vector of OMOP concept IDs to classify\nconn - Database connection using DBInterface\n\nKeyword Arguments\n\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDict{String, Vector{Int}} - Dictionary mapping domain names to vectors of concept IDs\n\nExamples\n\nconcepts = [201820, 192671, 1503297]\ndomains = _get_concepts_by_domain(concepts, conn)\n# Returns: Dict(\"Condition\" => [201820, 192671], \"Drug\" => [1503297])\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._get_database_total_patients-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility._get_database_total_patients","text":"_get_database_total_patients(conn; schema=\"dbt_synthea_dev\")\n\nGet the total number of patients in the database.\n\nArguments\n\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\n\nReturns\n\nInt - Total count of people in the person table\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._get_person_ids_from_cohort_table-Tuple{Any, Any}","page":"Home","title":"OMOPCDMFeasibility._get_person_ids_from_cohort_table","text":"_get_person_ids_from_cohort_table(cohort_definition_id, conn; schema=\"dbt_synthea_dev\")\n\nExtract person IDs from the cohort table using a cohort definition ID.\n\nArguments\n\ncohort_definition_id - ID of the cohort definition\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\n\nReturns\n\nVector - Vector of unique person IDs (subject_id from cohort table)\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._get_person_ids_from_dataframe-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility._get_person_ids_from_dataframe","text":"_get_person_ids_from_dataframe(cohort_df)\n\nExtract person IDs from a cohort DataFrame.\n\nArguments\n\ncohort_df - DataFrame containing cohort with person_id column\n\nReturns\n\nVector - Vector of unique person IDs from the DataFrame\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._resolve_table-Tuple{FunSQL.SQLConnection, Symbol}","page":"Home","title":"OMOPCDMFeasibility._resolve_table","text":"_resolve_table(fconn::SQLConnection, tblsym::Symbol) -> Table\n\nResolves a table symbol to its corresponding FunSQL table object.\n\nThis internal function looks up a table by name in the FunSQL catalog, performing case-insensitive matching.\n\nArguments\n\nfconn - FunSQL SQLConnection object\ntblsym - Table symbol to resolve\n\nReturns\n\nTable - FunSQL table object\n\nThrows\n\nErrorException - If the table is not found in the catalog\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility._setup_domain_query-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility._setup_domain_query","text":"_setup_domain_query(conn; domain::Symbol, schema::String=\"main\", dialect::Symbol=:postgresql) -> NamedTuple\n\nSets up the necessary components for querying a specific domain table.\n\nThis internal function prepares all the components needed to query a domain-specific table including the FunSQL connection, resolved table objects, and appropriate concept column name.\n\nArguments\n\nconn - Database connection\n\nKeyword Arguments\n\ndomain - Domain table symbol (e.g., :condition_occurrence)\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nNamedTuple - Contains fconn, tbl, concepttable, and conceptcol components\n\nExamples\n\nsetup = _setup_domain_query(conn; domain=:condition_occurrence)\n# Returns: (fconn=..., tbl=..., concept_table=..., concept_col=:condition_concept_id)\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility.analyze_concept_distribution-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility.analyze_concept_distribution","text":"analyze_concept_distribution(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql\n)\n\nAnalyzes the distribution of medical concepts across patient demographics by automatically detecting domains.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic stratification. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDataFrame - Summary statistics with columns for concept information, domain, covariate values, and patient counts (count)\n\nExamples\n\n# Basic concept summary with automatic domain detection\ndf = analyze_concept_distribution(conn; concept_set=[31967, 4059650])\n\n# With demographic breakdown\ndf = analyze_concept_distribution(\n    conn;\n    concept_set=[31967, 4059650], \n    covariate_funcs=[GetPatientGender, GetPatientAgeGroup]\n)\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility.create_cartesian_profiles-Tuple{}","page":"Home","title":"OMOPCDMFeasibility.create_cartesian_profiles","text":"create_cartesian_profiles(;\n    cohort_definition_id::Union{Int, Nothing} = nothing,\n    cohort_df::Union{DataFrame, Nothing} = nothing,\n    conn,\n    covariate_funcs::AbstractVector{<:Function},\n    schema::String = \"dbt_synthea_dev\",\n    dialect::Symbol = :postgresql\n)\n\nCreates Cartesian product demographic profiles for a cohort by analyzing all combinations of covariates.\n\nThis function generates a single DataFrame containing all possible combinations of demographic  covariates (e.g., gender × race × agegroup), providing comprehensive cross-tabulated statistics  for detailed post-cohort feasibility analysis. Column order matches the input `covariatefuncs` order, and results are sorted by covariate values for interpretable output.\n\nArguments\n\nconn - Database connection using DBInterface\ncovariate_funcs - Vector of covariate functions from OMOPCDMCohortCreator (must contain at least 2 functions)\n\nKeyword Arguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing). Either this or cohort_df must be provided\ncohort_df - DataFrame containing cohort with person_id column (or nothing). Either this or cohort_definition_id must be provided\nschema - Database schema name. Default: \"dbt_synthea_dev\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDataFrame - Cross-tabulated profile table with all covariate combinations and statistics\n\nExamples\n\nusing OMOPCDMCohortCreator: GetPatientAgeGroup, GetPatientGender, GetPatientRace\n\ncartesian_profiles = create_cartesian_profiles(\n    cohort_df = my_cohort_df,\n    conn = conn,\n    covariate_funcs = [GetPatientAgeGroup, GetPatientGender, GetPatientRace]\n)\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility.create_individual_profiles-Tuple{}","page":"Home","title":"OMOPCDMFeasibility.create_individual_profiles","text":"create_individual_profiles(;\n    cohort_definition_id::Union{Int, Nothing} = nothing,\n    cohort_df::Union{DataFrame, Nothing} = nothing,\n    conn,\n    covariate_funcs::AbstractVector{<:Function},\n    schema::String = \"dbt_synthea_dev\",\n    dialect::Symbol = :postgresql\n)\n\nCreates individual demographic profile tables for a cohort by analyzing each covariate separately.\n\nThis function generates separate DataFrames for each demographic covariate (e.g., gender, race, age group), providing detailed statistics including cohort and database-level percentages for post-cohort feasibility analysis. Results are sorted alphabetically by covariate values for consistent, readable output.\n\nArguments\n\nconn - Database connection using DBInterface\ncovariate_funcs - Vector of covariate functions from OMOPCDMCohortCreator (e.g., GetPatientGender, GetPatientRace)\n\nKeyword Arguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing). Either this or cohort_df must be provided\ncohort_df - DataFrame containing cohort with person_id column (or nothing). Either this or cohort_definition_id must be provided  \nschema - Database schema name. Default: \"dbt_synthea_dev\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nNamedTuple - Named tuple with keys corresponding to covariate names, each containing a DataFrame with covariate categories and statistics\n\nExamples\n\nusing OMOPCDMCohortCreator: GetPatientGender, GetPatientRace, GetPatientAgeGroup\n\nindividual_profiles = create_individual_profiles(\n    cohort_df = my_cohort_df,\n    conn = conn,\n    covariate_funcs = [GetPatientGender, GetPatientRace, GetPatientAgeGroup]\n)\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility.generate_domain_breakdown-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility.generate_domain_breakdown","text":"generate_domain_breakdown(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql,\n    raw_values::Bool = false\n)\n\nGenerates a detailed breakdown of feasibility metrics by medical domain.\n\nThis function provides domain-specific statistics showing concepts, patients, records, and coverage for each medical domain in the concept set. This is useful for understanding which domains contribute most to study feasibility.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic analysis. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\nraw_values - If true, returns raw numerical values; if false, returns formatted strings. Default: false\n\nReturns\n\nDataFrame - Domain-specific metrics with columns: metric, value, interpretation, and domain\n\nExamples\n\n# Get formatted breakdown (default)\nbreakdown = generate_domain_breakdown(conn; concept_set=[31967, 4059650])\n\n# Get raw numerical values for calculations\nbreakdown_raw = generate_domain_breakdown(conn; concept_set=[31967, 4059650], raw_values=true)\n\n\n\n\n\n","category":"method"},{"location":"#OMOPCDMFeasibility.generate_summary-Tuple{Any}","page":"Home","title":"OMOPCDMFeasibility.generate_summary","text":"generate_summary(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql,\n    raw_values::Bool = false\n)\n\nGenerates a summary of feasibility metrics for the given concept set.\n\nThis function provides high-level summary statistics including total patients, eligible patients, total records, and population coverage metrics. This is useful for getting a quick overview of study feasibility without detailed domain breakdowns.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic analysis. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\nraw_values - If true, returns raw numerical values; if false, returns formatted strings. Default: false\n\nReturns\n\nDataFrame - Summary metrics with columns: metric, value, interpretation, and domain\n\nExamples\n\n# Get formatted summary (default)\nsummary = generate_summary(conn; concept_set=[31967, 4059650])\n\n# Get raw numerical values for calculations\nsummary_raw = generate_summary(conn; concept_set=[31967, 4059650], raw_values=true)\n\n\n\n\n\n","category":"method"}]
}
