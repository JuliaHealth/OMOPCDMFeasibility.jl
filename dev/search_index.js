var documenterSearchIndex = {"docs":
[{"location":"api/#OMOPCDMFeasibility","page":"API","title":"OMOPCDMFeasibility","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for OMOPCDMFeasibility.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#OMOPCDMFeasibility._concept_col-Tuple{Symbol}","page":"API","title":"OMOPCDMFeasibility._concept_col","text":"_concept_col(tblsym::Symbol) -> Symbol\n\nGenerates the concept column name for a given table symbol.\n\nThis is an internal helper function that constructs the appropriate concept column name based on table naming conventions. Special handling is provided for the person table which uses genderconceptid.\n\nArguments\n\ntblsym - The table symbol\n\nReturns\n\nSymbol - The concept column name for that table\n\nExamples\n\ncol = _concept_col(:condition_occurrence)\n# Returns: :condition_concept_id\n\ncol = _concept_col(:person)\n# Returns: :gender_concept_id\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._counter_reducer-Tuple{Any, Any}","page":"API","title":"OMOPCDMFeasibility._counter_reducer","text":"_counter_reducer(sub, funcs) -> Any\n\nApplies a sequence of functions to a subject, reducing through function composition.\n\nThis internal helper function sequentially applies each function in the funcs vector to the result of the previous function, starting with sub.\n\nArguments\n\nsub - Initial subject/input to transform\nfuncs - Vector of functions to apply sequentially\n\nReturns\n\nAny - Result after applying all functions\n\nExamples\n\nresult = _counter_reducer([1,2,3], [x -> x .* 2, sum])\n# Equivalent to: sum([1,2,3] .* 2) = sum([2,4,6]) = 12\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._create_cartesian_profile_table-Tuple{DataFrames.DataFrame, Any, Int64, Int64, Any}","page":"API","title":"OMOPCDMFeasibility._create_cartesian_profile_table","text":"_create_cartesian_profile_table(df, cols, cohort_size, database_size, conn; schema=\"dbt_synthea_dev\", dialect=:postgresql)\n\nCreate a Cartesian product profile table with all covariate combinations.\n\nArguments\n\ndf - DataFrame with demographic data\ncols - Vector of column names to include in combinations\ncohort_size - Total cohort size\ndatabase_size - Total database population size\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\ndialect - SQL dialect (default: :postgresql)\n\nReturns\n\nDataFrame - Table with all covariate combinations and statistics\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._create_individual_profile_table-Tuple{DataFrames.DataFrame, Any, Int64, Int64, Any}","page":"API","title":"OMOPCDMFeasibility._create_individual_profile_table","text":"_create_individual_profile_table(df, col, cohort_size, database_size, conn; schema=\"dbt_synthea_dev\", dialect=:postgresql)\n\nCreate an individual profile table for a single covariate column.\n\nArguments\n\ndf - DataFrame with demographic data\ncol - Column name to profile\ncohort_size - Total cohort size\ndatabase_size - Total database population size\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\ndialect - SQL dialect (default: :postgresql)\n\nReturns\n\nDataFrame - Profile table with covariate categories and statistics\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._domain_id_to_table-Tuple{String}","page":"API","title":"OMOPCDMFeasibility._domain_id_to_table","text":"_domain_id_to_table(domain_id::String) -> Symbol\n\nMaps OMOP domain_id strings to their corresponding database table symbols.\n\nThis function provides the mapping between OMOP domain classifications and the actual database tables where those concepts are stored. It includes special handling for person-related domains and falls back to a naming convention for unknown domains.\n\nArguments\n\ndomain_id - OMOP domain identifier string (e.g., \"Condition\", \"Drug\")\n\nReturns\n\nSymbol - Database table symbol (e.g., :conditionoccurrence, :drugexposure)\n\nExamples\n\ntable = _domain_id_to_table(\"Condition\")\n# Returns: :condition_occurrence\n\ntable = _domain_id_to_table(\"Gender\") \n# Returns: :person\n\ntable = _domain_id_to_table(\"CustomDomain\")\n# Returns: :customdomain_occurrence\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._format_number-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility._format_number","text":"_format_number(n) -> String\n\nFormats a number into a human-readable string with appropriate scaling.\n\nThis utility function formats numbers using common abbreviations:\n\nNumbers â‰¥ 1,000,000 are formatted as \"X.XM\" (millions)\nNumbers â‰¥ 1,000 are formatted as \"X.XK\" (thousands)  \nNumbers < 1,000 are formatted as integers with ties rounded up\n\nArguments\n\nn - Number to format\n\nReturns\n\nString - Formatted number string\n\nExamples\n\n_format_number(1234567)  # Returns: \"1.2M\"\n_format_number(5432)     # Returns: \"5.4K\" \n_format_number(123)      # Returns: \"123\"\n_format_number(0.5)      # Returns: \"1\"\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._funsql-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility._funsql","text":"_funsql(conn; schema::String=\"main\", dialect::Symbol=:postgresql) -> SQLConnection\n\nCreates a FunSQL connection with database schema reflection.\n\nThis internal function sets up a FunSQL SQLConnection with the appropriate database dialect and schema reflection for query building. Use :postgresql for DuckDB and :sqlite for SQLite.\n\nArguments\n\nconn - Raw database connection\n\nKeyword Arguments\n\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nSQLConnection - FunSQL connection object with reflected schema\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._get_category_name-Tuple{Any, Any, Any}","page":"API","title":"OMOPCDMFeasibility._get_category_name","text":"_get_category_name(value, col, conn; schema=\"dbt_synthea_dev\", dialect=:postgresql)\n\nGet the human-readable category name for a covariate value.\n\nArguments\n\nvalue - The value to convert (concept ID or string)\ncol - The column name\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\ndialect - SQL dialect (default: :postgresql)\n\nReturns\n\nString - Human-readable category name\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._get_cohort_person_ids-Tuple{Any, Any, Any}","page":"API","title":"OMOPCDMFeasibility._get_cohort_person_ids","text":"_get_cohort_person_ids(cohort_definition_id, cohort_df, conn; schema=\"dbt_synthea_dev\")\n\nExtract person IDs from either a cohort definition ID or a cohort DataFrame.\n\nArguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing)\ncohort_df - DataFrame containing cohort with person_id column (or nothing)\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\n\nReturns\n\nVector - Vector of unique person IDs\n\nNotes\n\nYou must provide exactly one of cohort_definition_id or cohort_df (not both).\nIf both are provided, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._get_concept_name-Tuple{Any, Any}","page":"API","title":"OMOPCDMFeasibility._get_concept_name","text":"_get_concept_name(concept_id, conn; schema=\"main\", dialect=:postgresql) -> String\n\nRetrieves the human-readable name for a given OMOP concept ID.\n\nArguments\n\nconcept_id - OMOP CDM concept ID to look up\nconn - Database connection using DBInterface\n\nKeyword Arguments\n\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nString - The concept name, or \"Unknown\" if the concept ID is not found\n\nExamples\n\nname = _get_concept_name(8507, conn)\n# Returns: \"Male\"\n\nname = _get_concept_name(999999, conn) \n# Returns: \"Unknown\"\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._get_concepts_by_domain-Tuple{Vector{<:Integer}, Any}","page":"API","title":"OMOPCDMFeasibility._get_concepts_by_domain","text":"_get_concepts_by_domain(concept_ids::Vector{<:Integer}, conn; schema=\"main\", dialect=:postgresql) -> Dict{String, Vector{Int}}\n\nGroups a list of OMOP concept IDs by their domain classification.\n\nThis function queries the concept table to determine which domain each concept belongs to (e.g., \"Condition\", \"Drug\", \"Procedure\") and returns them grouped by domain.\n\nArguments\n\nconcept_ids - Vector of OMOP concept IDs to classify\nconn - Database connection using DBInterface\n\nKeyword Arguments\n\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDict{String, Vector{Int}} - Dictionary mapping domain names to vectors of concept IDs\n\nExamples\n\nconcepts = [201820, 192671, 1503297]\ndomains = _get_concepts_by_domain(concepts, conn)\n# Returns: Dict(\"Condition\" => [201820, 192671], \"Drug\" => [1503297])\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._get_database_total_patients-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility._get_database_total_patients","text":"_get_database_total_patients(conn; schema=\"dbt_synthea_dev\")\n\nGet the total number of patients in the database.\n\nArguments\n\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\n\nReturns\n\nInt - Total count of people in the person table\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._get_person_ids_from_cohort_table-Tuple{Any, Any}","page":"API","title":"OMOPCDMFeasibility._get_person_ids_from_cohort_table","text":"_get_person_ids_from_cohort_table(cohort_definition_id, conn; schema=\"dbt_synthea_dev\")\n\nExtract person IDs from the cohort table using a cohort definition ID.\n\nArguments\n\ncohort_definition_id - ID of the cohort definition\nconn - Database connection object\nschema - Database schema name (default: \"dbtsyntheadev\")\n\nReturns\n\nVector - Vector of unique person IDs (subject_id from cohort table)\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._get_person_ids_from_dataframe-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility._get_person_ids_from_dataframe","text":"_get_person_ids_from_dataframe(cohort_df)\n\nExtract person IDs from a cohort DataFrame.\n\nArguments\n\ncohort_df - DataFrame containing cohort with person_id column\n\nReturns\n\nVector - Vector of unique person IDs from the DataFrame\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._resolve_table-Tuple{FunSQL.SQLConnection, Symbol}","page":"API","title":"OMOPCDMFeasibility._resolve_table","text":"_resolve_table(fconn::SQLConnection, tblsym::Symbol) -> Table\n\nResolves a table symbol to its corresponding FunSQL table object.\n\nThis internal function looks up a table by name in the FunSQL catalog, performing case-insensitive matching.\n\nArguments\n\nfconn - FunSQL SQLConnection object\ntblsym - Table symbol to resolve\n\nReturns\n\nTable - FunSQL table object\n\nThrows\n\nErrorException - If the table is not found in the catalog\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility._setup_domain_query-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility._setup_domain_query","text":"_setup_domain_query(conn; domain::Symbol, schema::String=\"main\", dialect::Symbol=:postgresql) -> NamedTuple\n\nSets up the necessary components for querying a specific domain table.\n\nThis internal function prepares all the components needed to query a domain-specific table including the FunSQL connection, resolved table objects, and appropriate concept column name.\n\nArguments\n\nconn - Database connection\n\nKeyword Arguments\n\ndomain - Domain table symbol (e.g., :condition_occurrence)\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nNamedTuple - Contains fconn, tbl, concepttable, and conceptcol components\n\nExamples\n\nsetup = _setup_domain_query(conn; domain=:condition_occurrence)\n# Returns: (fconn=..., tbl=..., concept_table=..., concept_col=:condition_concept_id)\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility.analyze_concept_distribution-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility.analyze_concept_distribution","text":"analyze_concept_distribution(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql\n)\n\nAnalyzes the distribution of medical concepts across patient demographics by automatically detecting domains.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic stratification. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDataFrame - Summary statistics with columns for concept information, domain, covariate values, and patient counts (count)\n\nExamples\n\n# Basic concept summary with automatic domain detection\ndf = analyze_concept_distribution(conn; concept_set=[31967, 4059650])\n\n# With demographic breakdown\ndf = analyze_concept_distribution(\n    conn;\n    concept_set=[31967, 4059650], \n    covariate_funcs=[GetPatientGender, GetPatientAgeGroup]\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility.create_cartesian_profiles-Tuple{}","page":"API","title":"OMOPCDMFeasibility.create_cartesian_profiles","text":"create_cartesian_profiles(;\n    cohort_definition_id::Union{Int, Nothing} = nothing,\n    cohort_df::Union{DataFrame, Nothing} = nothing,\n    conn,\n    covariate_funcs::AbstractVector{<:Function},\n    schema::String = \"dbt_synthea_dev\",\n    dialect::Symbol = :postgresql\n)\n\nCreates Cartesian product demographic profiles for a cohort by analyzing all combinations of covariates.\n\nThis function generates a single DataFrame containing all possible combinations of demographic  covariates (e.g., gender Ã— race Ã— agegroup), providing comprehensive cross-tabulated statistics  for detailed post-cohort feasibility analysis. Column order matches the input `covariatefuncs` order, and results are sorted by covariate values for interpretable output.\n\nArguments\n\nconn - Database connection using DBInterface\ncovariate_funcs - Vector of covariate functions from OMOPCDMCohortCreator (must contain at least 2 functions)\n\nKeyword Arguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing). Either this or cohort_df must be provided\ncohort_df - DataFrame containing cohort with person_id column (or nothing). Either this or cohort_definition_id must be provided\nschema - Database schema name. Default: \"dbt_synthea_dev\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDataFrame - Cross-tabulated profile table with all covariate combinations and statistics\n\nExamples\n\nusing OMOPCDMCohortCreator: GetPatientAgeGroup, GetPatientGender, GetPatientRace\n\ncartesian_profiles = create_cartesian_profiles(\n    cohort_df = my_cohort_df,\n    conn = conn,\n    covariate_funcs = [GetPatientAgeGroup, GetPatientGender, GetPatientRace]\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility.create_individual_profiles-Tuple{}","page":"API","title":"OMOPCDMFeasibility.create_individual_profiles","text":"create_individual_profiles(;\n    cohort_definition_id::Union{Int, Nothing} = nothing,\n    cohort_df::Union{DataFrame, Nothing} = nothing,\n    conn,\n    covariate_funcs::AbstractVector{<:Function},\n    schema::String = \"dbt_synthea_dev\",\n    dialect::Symbol = :postgresql\n)\n\nCreates individual demographic profile tables for a cohort by analyzing each covariate separately.\n\nThis function generates separate DataFrames for each demographic covariate (e.g., gender, race, age group), providing detailed statistics including cohort and database-level percentages for post-cohort feasibility analysis. Results are sorted alphabetically by covariate values for consistent, readable output.\n\nArguments\n\nconn - Database connection using DBInterface\ncovariate_funcs - Vector of covariate functions from OMOPCDMCohortCreator (e.g., GetPatientGender, GetPatientRace)\n\nKeyword Arguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing). Either this or cohort_df must be provided\ncohort_df - DataFrame containing cohort with person_id column (or nothing). Either this or cohort_definition_id must be provided  \nschema - Database schema name. Default: \"dbt_synthea_dev\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nNamedTuple - Named tuple with keys corresponding to covariate names, each containing a DataFrame with covariate categories and statistics\n\nExamples\n\nusing OMOPCDMCohortCreator: GetPatientGender, GetPatientRace, GetPatientAgeGroup\n\nindividual_profiles = create_individual_profiles(\n    cohort_df = my_cohort_df,\n    conn = conn,\n    covariate_funcs = [GetPatientGender, GetPatientRace, GetPatientAgeGroup]\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility.generate_domain_breakdown-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility.generate_domain_breakdown","text":"generate_domain_breakdown(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql,\n    raw_values::Bool = false\n)\n\nGenerates a detailed breakdown of feasibility metrics by medical domain.\n\nThis function provides domain-specific statistics showing concepts, patients, records, and coverage for each medical domain in the concept set. This is useful for understanding which domains contribute most to study feasibility.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic analysis. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\nraw_values - If true, returns raw numerical values; if false, returns formatted strings. Default: false\n\nReturns\n\nDataFrame - Domain-specific metrics with columns: metric, value, interpretation, and domain\n\nExamples\n\n# Get formatted breakdown (default)\nbreakdown = generate_domain_breakdown(conn; concept_set=[31967, 4059650])\n\n# Get raw numerical values for calculations\nbreakdown_raw = generate_domain_breakdown(conn; concept_set=[31967, 4059650], raw_values=true)\n\n\n\n\n\n","category":"method"},{"location":"api/#OMOPCDMFeasibility.generate_summary-Tuple{Any}","page":"API","title":"OMOPCDMFeasibility.generate_summary","text":"generate_summary(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql,\n    raw_values::Bool = false\n)\n\nGenerates a summary of feasibility metrics for the given concept set.\n\nThis function provides high-level summary statistics including total patients, eligible patients, total records, and population coverage metrics. This is useful for getting a quick overview of study feasibility without detailed domain breakdowns.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic analysis. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\nraw_values - If true, returns raw numerical values; if false, returns formatted strings. Default: false\n\nReturns\n\nDataFrame - Summary metrics with columns: metric, value, interpretation, and domain\n\nExamples\n\n# Get formatted summary (default)\nsummary = generate_summary(conn; concept_set=[31967, 4059650])\n\n# Get raw numerical values for calculations\nsummary_raw = generate_summary(conn; concept_set=[31967, 4059650], raw_values=true)\n\n\n\n\n\n","category":"method"},{"location":"precohort/#Pre-Cohort-Analysis","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"","category":"section"},{"location":"precohort/","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"What is Feasibility Analysis?","category":"page"},{"location":"precohort/","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"Feasibility analysis is the process of checking if your planned study or cohort is possible and meaningful with the data you have. It helps you answer questions like: Are there enough patients? Are the concepts I care about present? Is the data complete and reliable?","category":"page"},{"location":"precohort/","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"What is Pre-Cohort Analysis?","category":"page"},{"location":"precohort/","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"Pre-cohort analysis is the first step in any observational health study. Before you define your study population (the \"cohort\"), you use pre-cohort tools to explore your OMOP CDM database. This helps you:","category":"page"},{"location":"precohort/","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"Understand what data is available\nCheck the frequency and quality of key concepts\nPlan your study with confidence","category":"page"},{"location":"precohort/","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"Pre-cohort analysis is like scouting the terrain before starting a journeyâ€”it helps you avoid surprises and design better, more robust studies.","category":"page"},{"location":"precohort/#1.-analyze_concept_distribution","page":"Pre-Cohort Analysis","title":"1. analyze_concept_distribution","text":"","category":"section"},{"location":"precohort/#OMOPCDMFeasibility.analyze_concept_distribution","page":"Pre-Cohort Analysis","title":"OMOPCDMFeasibility.analyze_concept_distribution","text":"analyze_concept_distribution(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql\n)\n\nAnalyzes the distribution of medical concepts across patient demographics by automatically detecting domains.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic stratification. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDataFrame - Summary statistics with columns for concept information, domain, covariate values, and patient counts (count)\n\nExamples\n\n# Basic concept summary with automatic domain detection\ndf = analyze_concept_distribution(conn; concept_set=[31967, 4059650])\n\n# With demographic breakdown\ndf = analyze_concept_distribution(\n    conn;\n    concept_set=[31967, 4059650], \n    covariate_funcs=[GetPatientGender, GetPatientAgeGroup]\n)\n\n\n\n\n\n","category":"function"},{"location":"precohort/#2.-generate_summary","page":"Pre-Cohort Analysis","title":"2. generate_summary","text":"","category":"section"},{"location":"precohort/#OMOPCDMFeasibility.generate_summary","page":"Pre-Cohort Analysis","title":"OMOPCDMFeasibility.generate_summary","text":"generate_summary(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql,\n    raw_values::Bool = false\n)\n\nGenerates a summary of feasibility metrics for the given concept set.\n\nThis function provides high-level summary statistics including total patients, eligible patients, total records, and population coverage metrics. This is useful for getting a quick overview of study feasibility without detailed domain breakdowns.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic analysis. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\nraw_values - If true, returns raw numerical values; if false, returns formatted strings. Default: false\n\nReturns\n\nDataFrame - Summary metrics with columns: metric, value, interpretation, and domain\n\nExamples\n\n# Get formatted summary (default)\nsummary = generate_summary(conn; concept_set=[31967, 4059650])\n\n# Get raw numerical values for calculations\nsummary_raw = generate_summary(conn; concept_set=[31967, 4059650], raw_values=true)\n\n\n\n\n\n","category":"function"},{"location":"precohort/#3.-generate_domain_breakdown","page":"Pre-Cohort Analysis","title":"3. generate_domain_breakdown","text":"","category":"section"},{"location":"precohort/#OMOPCDMFeasibility.generate_domain_breakdown","page":"Pre-Cohort Analysis","title":"OMOPCDMFeasibility.generate_domain_breakdown","text":"generate_domain_breakdown(\n    conn;\n    concept_set::Vector{<:Integer},\n    covariate_funcs::AbstractVector{<:Function} = Function[],\n    schema::String = \"main\",\n    dialect::Symbol = :postgresql,\n    raw_values::Bool = false\n)\n\nGenerates a detailed breakdown of feasibility metrics by medical domain.\n\nThis function provides domain-specific statistics showing concepts, patients, records, and coverage for each medical domain in the concept set. This is useful for understanding which domains contribute most to study feasibility.\n\nArguments\n\nconn - Database connection using DBInterface\nconcept_set - Vector of OMOP concept IDs to analyze; must be subtype of Integer\n\nKeyword Arguments\n\ncovariate_funcs - Vector of OMOPCDMCohortCreator functions for demographic analysis. Default: Function[]\nschema - Database schema name. Default: \"main\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\nraw_values - If true, returns raw numerical values; if false, returns formatted strings. Default: false\n\nReturns\n\nDataFrame - Domain-specific metrics with columns: metric, value, interpretation, and domain\n\nExamples\n\n# Get formatted breakdown (default)\nbreakdown = generate_domain_breakdown(conn; concept_set=[31967, 4059650])\n\n# Get raw numerical values for calculations\nbreakdown_raw = generate_domain_breakdown(conn; concept_set=[31967, 4059650], raw_values=true)\n\n\n\n\n\n","category":"function"},{"location":"precohort/#Example:-Pre-Cohort-Analysis-in-Practice","page":"Pre-Cohort Analysis","title":"Example: Pre-Cohort Analysis in Practice","text":"","category":"section"},{"location":"precohort/","page":"Pre-Cohort Analysis","title":"Pre-Cohort Analysis","text":"using DataFrames, DuckDB, DBInterface\nusing OMOPCDMFeasibility\nusing OMOPCDMCohortCreator:\n    GenerateDatabaseDetails,\n    GenerateTables,\n    GetPatientGender,\n    GetPatientAgeGroup,\n    GetPatientRace,\n    GetPatientEthnicity,\n    ConditionFilterPersonIDs\n\nconn = DBInterface.connect(DuckDB.DB, \"synthea_1M_3YR.duckdb\")\n\nGenerateDatabaseDetails(:postgresql, \"dbt_synthea_dev\")\nGenerateTables(conn)\n\nconcept_ids = [\n    31967,    # Condition: Nausea\n    1127433,  # Drug: Acetaminophen\n]\n\nprintln(\"\\n\")\ndistribution = OMOPCDMFeasibility.analyze_concept_distribution(\n    conn;\n    concept_set=concept_ids,\n    covariate_funcs=[GetPatientGender, GetPatientRace],\n    schema=\"dbt_synthea_dev\"\n)\ndisplay(distribution)\n\nprintln(\"\\n\")\nsummary = OMOPCDMFeasibility.generate_summary(\n    conn;\n    concept_set=concept_ids,\n    covariate_funcs=[GetPatientAgeGroup, GetPatientRace],\n    schema=\"dbt_synthea_dev\"\n)\ndisplay(summary)\n\nprintln(\"\\n\")\ndomain_breakdown = OMOPCDMFeasibility.generate_domain_breakdown(\n    conn;\n    concept_set=concept_ids,\n    schema=\"dbt_synthea_dev\"\n)\ndisplay(domain_breakdown)\nprintln()\n\nDBInterface.close!(conn)","category":"page"},{"location":"quickstart/#Quickstart","page":"Quickstart","title":"Quickstart ðŸŽ‰","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Welcome to the Quickstart guide for OMOPCDMFeasibility.jl! This guide shows you how to set up your Julia environment and use OMOPCDMFeasibility.jl for pre- and post-cohort analysis-after you have created a cohort using the recommended observational window template workflow.","category":"page"},{"location":"quickstart/#1.-Getting-Started","page":"Quickstart","title":"1. Getting Started","text":"","category":"section"},{"location":"quickstart/#Launch-Julia-and-Enter-Your-Project-Environment","page":"Quickstart","title":"Launch Julia and Enter Your Project Environment","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To get started:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Open your terminal or Julia REPL.\nNavigate to your project folder (where Project.toml is located):","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"cd path/to/your/project","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Activate the project:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"julia --project=.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"(Optional for docs) For working on documentation:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"julia --project=docs","category":"page"},{"location":"quickstart/#2.-Create-Your-Cohort-with-the-Observation-Window-Template","page":"Quickstart","title":"2. Create Your Cohort with the Observation Window Template","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"For a robust, reproducible template for observational study setup and cohort creation, follow the official workflow :Observational Template Workflow1. Go through steps 2â€“5 in the workflow to define and create your cohort table in your database.2. Once your cohort is created, return here to analyze it with OMOPCDMFeasibility.jl.","category":"page"},{"location":"quickstart/#3.-Pre-Cohort-Analysis","page":"Quickstart","title":"3. Pre-Cohort Analysis","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Explore your data before defining a cohort.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Pre-Cohort Analysis:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Pre-cohort functions (like analyze_concept_distribution) do not accept a cohort table or DataFrame. They always analyze the full database, but you can optionally stratify by covariates (e.g., gender, race, age group) using the covariate_funcs argument.\nThe covariate_funcs argument is optional-include it if you want to stratify by covariates.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To use covariate getter functions, import them from OMOPCDMCohortCreator.jl:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using OMOPCDMCohortCreator: GetPatientGender, GetPatientRace, GetPatientAgeGroup","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"For more advanced understanding and options, see Pre-Cohort Analysis.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# Check how common specific OMOP concepts are in your database\n# 201826 = \"Hypertension\", 3004249 = \"Metformin\"\nanalyze_concept_distribution(conn; concept_set=[201826, 3004249], schema=\"main\")\n\n# Example with covariate_funcs (optional)\nanalyze_concept_distribution(\n   conn;\n   concept_set=[201826, 3004249],\n   covariate_funcs=[GetPatientGender, GetPatientRace],\n   schema=\"main\"\n)\n\n# Get summary statistics for a set of concepts\ngenerate_summary(conn; concept_set=[201826, 3004249], schema=\"main\")\n\n# See which OMOP domains your concepts belong to\ngenerate_domain_breakdown(conn; concept_set=[201826, 3004249], schema=\"main\")","category":"page"},{"location":"quickstart/#4.-Post-Cohort-Analysis","page":"Quickstart","title":"4. Post-Cohort Analysis","text":"","category":"section"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"After extracting your cohort, you can perform post-cohort analyses as shown below.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Post-Cohort Analysis:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Post-cohort functions (like create_individual_profiles) require you to provide either:\ncohort_definition_id (to use a cohort table in the database), or\ncohort_df (a DataFrame of person IDs).\nYou should provide only one of them.\nThe covariate_funcs argument is optional-include it if you want to stratify by covariates (e.g., gender, race, age group).","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"To use covariate getter functions, import them from OMOPCDMCohortCreator.jl:","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"using OMOPCDMCohortCreator: GetPatientGender, GetPatientRace, GetPatientAgeGroup","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"For more advanced understanding and options, see Post-Cohort Analysis.","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"# Example: Using a DataFrame\ncreate_individual_profiles(\n   cohort_df = sample_cohort,\n   conn = conn,\n   # covariate_funcs = [GetPatientGender, GetPatientRace], # optional\n   schema = \"main\"\n)\n\n# Example: Using a cohort_definition_id\ncreate_individual_profiles(\n   cohort_definition_id = 1,\n   conn = conn,\n   # covariate_funcs = [GetPatientGender, GetPatientRace], # optional\n   schema = \"main\"\n)","category":"page"},{"location":"quickstart/","page":"Quickstart","title":"Quickstart","text":"Happy experimenting with OMOPCDMFeasibility.jl! ðŸŽ‰","category":"page"},{"location":"postcohort/#Post-Cohort-Analysis","page":"Post-Cohort Analysis","title":"Post-Cohort Analysis","text":"","category":"section"},{"location":"postcohort/","page":"Post-Cohort Analysis","title":"Post-Cohort Analysis","text":"What is Post-Cohort Analysis?","category":"page"},{"location":"postcohort/","page":"Post-Cohort Analysis","title":"Post-Cohort Analysis","text":"Post-cohort analysis is the process of exploring and summarizing your study population after you have defined your cohort. It helps you answer questions like: Who is in my cohort? What are their characteristics? How do they compare to the rest of the database?","category":"page"},{"location":"postcohort/","page":"Post-Cohort Analysis","title":"Post-Cohort Analysis","text":"This step is essential for understanding your results, checking for biases, and making your study reproducible and transparent.","category":"page"},{"location":"postcohort/","page":"Post-Cohort Analysis","title":"Post-Cohort Analysis","text":"Post-cohort analysis in OMOPCDMFeasibility.jl is designed to be simple and clear, even for beginners.","category":"page"},{"location":"postcohort/#1.-create_individual_profiles","page":"Post-Cohort Analysis","title":"1. create_individual_profiles","text":"","category":"section"},{"location":"postcohort/#OMOPCDMFeasibility.create_individual_profiles","page":"Post-Cohort Analysis","title":"OMOPCDMFeasibility.create_individual_profiles","text":"create_individual_profiles(;\n    cohort_definition_id::Union{Int, Nothing} = nothing,\n    cohort_df::Union{DataFrame, Nothing} = nothing,\n    conn,\n    covariate_funcs::AbstractVector{<:Function},\n    schema::String = \"dbt_synthea_dev\",\n    dialect::Symbol = :postgresql\n)\n\nCreates individual demographic profile tables for a cohort by analyzing each covariate separately.\n\nThis function generates separate DataFrames for each demographic covariate (e.g., gender, race, age group), providing detailed statistics including cohort and database-level percentages for post-cohort feasibility analysis. Results are sorted alphabetically by covariate values for consistent, readable output.\n\nArguments\n\nconn - Database connection using DBInterface\ncovariate_funcs - Vector of covariate functions from OMOPCDMCohortCreator (e.g., GetPatientGender, GetPatientRace)\n\nKeyword Arguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing). Either this or cohort_df must be provided\ncohort_df - DataFrame containing cohort with person_id column (or nothing). Either this or cohort_definition_id must be provided  \nschema - Database schema name. Default: \"dbt_synthea_dev\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nNamedTuple - Named tuple with keys corresponding to covariate names, each containing a DataFrame with covariate categories and statistics\n\nExamples\n\nusing OMOPCDMCohortCreator: GetPatientGender, GetPatientRace, GetPatientAgeGroup\n\nindividual_profiles = create_individual_profiles(\n    cohort_df = my_cohort_df,\n    conn = conn,\n    covariate_funcs = [GetPatientGender, GetPatientRace, GetPatientAgeGroup]\n)\n\n\n\n\n\n","category":"function"},{"location":"postcohort/#2.-create_cartesian_profiles","page":"Post-Cohort Analysis","title":"2. create_cartesian_profiles","text":"","category":"section"},{"location":"postcohort/#OMOPCDMFeasibility.create_cartesian_profiles","page":"Post-Cohort Analysis","title":"OMOPCDMFeasibility.create_cartesian_profiles","text":"create_cartesian_profiles(;\n    cohort_definition_id::Union{Int, Nothing} = nothing,\n    cohort_df::Union{DataFrame, Nothing} = nothing,\n    conn,\n    covariate_funcs::AbstractVector{<:Function},\n    schema::String = \"dbt_synthea_dev\",\n    dialect::Symbol = :postgresql\n)\n\nCreates Cartesian product demographic profiles for a cohort by analyzing all combinations of covariates.\n\nThis function generates a single DataFrame containing all possible combinations of demographic  covariates (e.g., gender Ã— race Ã— agegroup), providing comprehensive cross-tabulated statistics  for detailed post-cohort feasibility analysis. Column order matches the input `covariatefuncs` order, and results are sorted by covariate values for interpretable output.\n\nArguments\n\nconn - Database connection using DBInterface\ncovariate_funcs - Vector of covariate functions from OMOPCDMCohortCreator (must contain at least 2 functions)\n\nKeyword Arguments\n\ncohort_definition_id - ID of the cohort definition in the cohort table (or nothing). Either this or cohort_df must be provided\ncohort_df - DataFrame containing cohort with person_id column (or nothing). Either this or cohort_definition_id must be provided\nschema - Database schema name. Default: \"dbt_synthea_dev\"\ndialect - Database dialect. Default: :postgresql (for DuckDB compatibility)\n\nReturns\n\nDataFrame - Cross-tabulated profile table with all covariate combinations and statistics\n\nExamples\n\nusing OMOPCDMCohortCreator: GetPatientAgeGroup, GetPatientGender, GetPatientRace\n\ncartesian_profiles = create_cartesian_profiles(\n    cohort_df = my_cohort_df,\n    conn = conn,\n    covariate_funcs = [GetPatientAgeGroup, GetPatientGender, GetPatientRace]\n)\n\n\n\n\n\n","category":"function"},{"location":"postcohort/#Example:-Post-Cohort-Analysis-in-Practice","page":"Post-Cohort Analysis","title":"Example: Post-Cohort Analysis in Practice","text":"","category":"section"},{"location":"postcohort/","page":"Post-Cohort Analysis","title":"Post-Cohort Analysis","text":"using DataFrames, DuckDB, DBInterface, Dates\nusing OMOPCDMFeasibility\nusing OMOPCDMCohortCreator:\n    GenerateDatabaseDetails,\n    GenerateTables,\n    GetPatientGender,\n    GetPatientAgeGroup,\n    GetPatientRace,\n    GetPatientEthnicity,\n    ConditionFilterPersonIDs\n\nconn = DBInterface.connect(DuckDB.DB, \"synthea_1M_3YR.duckdb\")\n\nGenerateDatabaseDetails(:postgresql, \"dbt_synthea_dev\")\nGenerateTables(conn)\n\ndiabetes_concept_ids = [201826]\ncohort_result = ConditionFilterPersonIDs(diabetes_concept_ids, conn)\ncohort_ids = cohort_result.person_id\n\nsample_cohort = DataFrame(\n    person_id = cohort_ids\n)\n\nprintln(\"Creating individual demographic profiles...\")\nindividual_demographics = OMOPCDMFeasibility.create_individual_profiles(\n    cohort_df=sample_cohort,\n    conn=conn,\n    covariate_funcs=[GetPatientGender, GetPatientRace, GetPatientAgeGroup]\n)\n\nprintln(\"Individual profiles:\")\nfor (name, table) in pairs(individual_demographics)\n    println(\"$name:\")\n    println(table)\n    println()\nend\n\nprintln(\"Creating Cartesian demographic profiles...\")\ncartesian_demographics = OMOPCDMFeasibility.create_cartesian_profiles(\n    cohort_df=sample_cohort,\n    conn=conn,\n    covariate_funcs=[GetPatientAgeGroup, GetPatientGender, GetPatientRace]\n)\n\nprintln(\"Cartesian profiles:\")\nprintln(cartesian_demographics)\n\nDBInterface.close!(conn)","category":"page"},{"location":"#OMOPCDMFeasibility.jl","page":"Home","title":"OMOPCDMFeasibility.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for feasibility and cohort analysis on OMOP Common Data Model (CDM) data.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OMOPCDMFeasibility.jl helps researchers and data scientists quickly explore, summarize, and compare patient cohorts using OMOP CDM databases. It is designed for use in observational health studies, cohort discovery, and data quality assessment.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pre-cohort analysis: Explore concept distributions, domain breakdowns, and data quality before defining a cohort.\nPost-cohort analysis: Summarize, profile, and compare cohorts after extraction.\nFlexible database support: Works with DuckDB, SQLite, PostgreSQL, and more.\nComposable with JuliaHealth: Integrates with DataFrames.jl, OMOPCommonDataModel.jl, and other JuliaHealth tools.\nReproducible workflows: Designed for robust, testable, and transparent research.\nClear error handling: Provides informative messages and input validation.","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OMOPCDMFeasibility.jl is focused on feasibility and cohort analysis only; it does not perform cohort extraction or patient-level prediction itself.\nSome advanced features (e.g., custom covariates, non-standard dialects) may require additional JuliaHealth packages or extensions.\nThe package assumes your data is already in OMOP CDM format and accessible via a supported database backend.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a step-by-step guide, see the Quickstart. For detailed workflows and function documentation, explore the other sections in this documentation.","category":"page"}]
}
